GGally::ggpairs(data = .data,
ggplot2::aes(colour = "steelblue", alpha = 0.5)) +
ggplot2::ggtitle(gg_title)
}
! LaTeX3 Error: Mismatched LaTeX support files detected.
tinytex::tlmgr_update()
usethis::edit_r_profile()
create_package("Desktop/DSCI_310/regexcite")
install.packages("tidyverse")
library(tidyverse)
tidyverse_update()
install.packages(c("dtplyr", "jsonlite", "pillar", "readr", "readxl"))
install.packages(c("dtplyr", "jsonlite", "pillar", "readr", "readxl"))
install.packages(c("cowplot", "GGally", "kknn", "scales", "tidyverse", "tidymodels"))
install.packages('IRkernel')
install.packages('tinytex')
tinytex::install_tinytex()
source("~/Documents/DSCI-310-Group-11/src/R/fit_model.R")
"Finds the best k value for the k-nn regression model using the training data,
and with pairs of predictors with the largest correlation coefficients
(DC, DMC, ISI, FFMC, temp, and RH).
Usage: /src/R/best_k.R --train_data=<train_data> --out_dir=<out_dir>
Options:
--train_data=<train-data>   Path to training data (saved as a .csv file)
--out_dir=<out_dir>         Path to directory where the best k value should be stored
" -> doc
library(tidyverse)
library(docopt)
opt <- docopt(doc)
best_k <- function(train_data, out_dir) {
# read training data
train_set <- read(train_data)
# create recipe
model_recipe <- recipe(area ~ DC + DMC + ISI + FFMC + temp + RH, train_set)
# create model specification
model_spec <- nearest_neighbor(weight_func = "rectangular", neighbors = tune()) |>
set_engine("kknn") |>
set_mode("regression")
# create workflow
model_wkflw <- workflow() |>
add_recipe(model_recipe) |>
add_model(model_spec)
# perform 5 fold cross-validation
model_cv <- vfold_cv(fire_train, v = 5, strata = area)
# hyperparameter tuning
gridvals <- tibble(neighbors = seq(from = 1, to = 200, by = 3))
model_results <- model_wkflw |>
tune_grid(resamples = fire_cv, grid = gridvals) |>
collect_metrics() |>
filter(.metric == "rmse")
min_rmse <- model_results |>
filter(mean == min(mean))
k_min <- min_rmse |>
pull(neighbors)
# save result as a .csv file
write_csv(k_min, "/results/best_k.csv")
}
main(opt[["--train_data"]], opt[["--out_dir"]])
"Finds the best k value for the k-nn regression model using the training data,
and with pairs of predictors with the largest correlation coefficients
(DC, DMC, ISI, FFMC, temp, and RH).
Usage: /src/R/best_k.R --train_data=<train_data> --out_dir=<out_dir>
Options:
--train_data=<train-data>   Path to training data (saved as a .csv file)
--out_dir=<out_dir>         Path to directory where the best k value should be stored
" -> doc
library(tidyverse)
library(docopt)
opt <- docopt(doc)
best_k <- function(train_data, out_dir) {
# read training data
train_set <- read(train_data)
# create recipe
model_recipe <- recipe(area ~ DC + DMC + ISI + FFMC + temp + RH, train_set)
# create model specification
model_spec <- nearest_neighbor(weight_func = "rectangular", neighbors = tune()) |>
set_engine("kknn") |>
set_mode("regression")
# create workflow
model_wkflw <- workflow() |>
add_recipe(model_recipe) |>
add_model(model_spec)
# perform 5 fold cross-validation
model_cv <- vfold_cv(fire_train, v = 5, strata = area)
# hyperparameter tuning
gridvals <- tibble(neighbors = seq(from = 1, to = 200, by = 3))
model_results <- model_wkflw |>
tune_grid(resamples = fire_cv, grid = gridvals) |>
collect_metrics() |>
filter(.metric == "rmse")
min_rmse <- model_results |>
filter(mean == min(mean))
k_min <- min_rmse |>
pull(neighbors)
# save result as a .csv file
write_csv(k_min, "/results/best_k.csv")
}
best_k(opt[["--train_data"]], opt[["--out_dir"]])
"Finds the best k value for the k-nn regression model using the training data,
and with pairs of predictors with the largest correlation coefficients
(DC, DMC, ISI, FFMC, temp, and RH).
Usage: /src/R/best_k.R --train_data=<train_data> --out_dir=<out_dir>
Options:
--train_data=<train-data>   Path to training data (saved as a .csv file)
--out_dir=<out_dir>         Path to directory where the best k value should be stored
" -> doc
library(tidyverse)
library(docopt)
opt <- docopt(doc)
best_k <- function(train_data, out_dir) {
# read training data
train_set <- read_csv(train_data)
# create recipe
model_recipe <- recipe(area ~ DC + DMC + ISI + FFMC + temp + RH, train_set)
# create model specification
model_spec <- nearest_neighbor(weight_func = "rectangular", neighbors = tune()) |>
set_engine("kknn") |>
set_mode("regression")
# create workflow
model_wkflw <- workflow() |>
add_recipe(model_recipe) |>
add_model(model_spec)
# perform 5 fold cross-validation
model_cv <- vfold_cv(fire_train, v = 5, strata = area)
# hyperparameter tuning
gridvals <- tibble(neighbors = seq(from = 1, to = 200, by = 3))
model_results <- model_wkflw |>
tune_grid(resamples = fire_cv, grid = gridvals) |>
collect_metrics() |>
filter(.metric == "rmse")
min_rmse <- model_results |>
filter(mean == min(mean))
k_min <- min_rmse |>
pull(neighbors)
# save result as a .csv file
write_csv(k_min, "/results/best_k.csv")
}
best_k(opt[["--train_data"]], opt[["--out_dir"]])
"Finds the best k value for the k-nn regression model using the training data,
and with pairs of predictors with the largest correlation coefficients
(DC, DMC, ISI, FFMC, temp, and RH).
Usage: /src/R/best_k.R --train_data=<train_data> --out_dir=<out_dir>
Options:
--train_data=<train-data>   Path to training data (saved as a .csv file)
--out_dir=<out_dir>         Path to directory where the best k value should be stored
" -> doc
library(tidyverse)
library(docopt)
opt <- docopt(doc)
best_k <- function(train_data, out_dir) {
# read training data
train_set <- read_csv(train_data)
# create recipe
model_recipe <- recipe(area ~ DC + DMC + ISI + FFMC + temp + RH, train_set)
# create model specification
model_spec <- nearest_neighbor(weight_func = "rectangular", neighbors = tune()) |>
set_engine("kknn") |>
set_mode("regression")
# create workflow
model_wkflw <- workflow() |>
add_recipe(model_recipe) |>
add_model(model_spec)
# perform 5 fold cross-validation
model_cv <- vfold_cv(fire_train, v = 5, strata = area)
# hyperparameter tuning
gridvals <- tibble(neighbors = seq(from = 1, to = 200, by = 3))
model_results <- model_wkflw |>
tune_grid(resamples = fire_cv, grid = gridvals) |>
collect_metrics() |>
filter(.metric == "rmse")
min_rmse <- model_results |>
filter(mean == min(mean))
k_min <- min_rmse |>
pull(neighbors)
# save result as a .csv file
write_csv(k_min, "/results/best_k.csv")
}
best_k(opt[["--train_data"]], opt[["--out_dir"]])
suppressPackageStartupMessages({
library(tidyverse)
library(tidymodels)
library(GGally)})
options(repr.plot.width = 15, repr.plot.height = 12)
source("../src/R/data_cleaning.R")
source("../src/R/correlation_graph.R")
source("../src/R/recipe_scale_center.R")
fire_data <- read_csv("../data/forestfires.csv", show_col_types = FALSE)
fire_data <- data_cleaning(fire_data, c('X','Y','month','day'))
"Table 1: Tidied Data"
head(fire_data)
fire_data <- read_csv("../data/forestfires.csv", show_col_types = FALSE)
fire_data <- data_cleaning(fire_data, c('X','Y','month','day'))
"Table 1: Tidied Data"
head(fire_data)
set.seed(2022)
fire_split <- initial_split(fire_data, prop = 0.75, strata = area)
fire_train <- training(fire_split)
fire_test <- testing(fire_split)
fire_recipe <- recipe_scale_center(fire_train, area ~ .)
fire_scaled <- fire_recipe %>%
prep() %>%
bake(fire_train)
suppressPackageStartupMessages({
library(tidyverse)
library(tidymodels)
library(GGally)})
options(repr.plot.width = 15, repr.plot.height = 12)
source("../src/R/data_cleaning.R")
source("../src/R/correlation_graph.R")
source("../src/R/recipe_scale_center.R")
fire_data <- read_csv("../data/forestfires.csv", show_col_types = FALSE)
fire_data <- data_cleaning(fire_data, c('X','Y','month','day'))
"Table 1: Tidied Data"
head(fire_data)
set.seed(2022)
fire_split <- initial_split(fire_data, prop = 0.75, strata = area)
fire_train <- training(fire_split)
fire_test <- testing(fire_split)
fire_recipe <- recipe_scale_center(fire_train, area ~ .)
fire_scaled <- fire_recipe %>%
prep() %>%
bake(fire_train)
View(fire_train)
main <- function(train_data, out_dir) {
# read training data
train_set <- read.csv(train_data)
# create recipe
model_recipe <- recipe(area ~ DC + DMC + ISI + FFMC + temp + RH, train_set)
# create model specification
model_spec <- nearest_neighbor(weight_func = "rectangular", neighbors = tune()) |>
set_engine("kknn") |>
set_mode("regression")
# create workflow
model_wkflw <- workflow() |>
add_recipe(model_recipe) |>
add_model(model_spec)
# perform 5 fold cross-validation
model_cv <- vfold_cv(train_data, v = 5, strata = area)
# hyperparameter tuning
gridvals <- tibble(neighbors = seq(from = 1, to = 200, by = 3))
model_results <- model_wkflw |>
tune_grid(resamples = model_cv, grid = gridvals) |>
collect_metrics() |>
filter(.metric == "rmse")
min_rmse <- model_results |>
filter(mean == min(mean))
k_min <- min_rmse |>
pull(neighbors)
# save result as a .csv file
write_csv(k_min, "results/best_k.csv")
}
main(fire_train, "results/best_k.csv")
main(fire_train, "/results/best_k.csv")
main(data/forestfires.csv, "results/best_k.csv")
main(Documents/DSCI-310-Group-11/data/forestfires.csv, "results/best_k.csv")
setwd("~/Documents/DSCI-310-Group-11")
ls
main(fire_train, "results/best_k.csv")
"This script creates fits the given model on the test set and produces the RMSE value.
Usage: src/R/model_summary.R <model_recipe> <model_spec> <train_set> <test_set> <predictor>
" -> doc
library(tidyverse)
library(tidymodels)
library(docopt)
opt <- docopt(doc)
model_fit <- workflow() |>
add_recipe(opt$model_recipe) |>
add_model(opt$model_spec) |>
fit(data = opt$train_set)
model_summary <- model_fit |>
predict(opt$test_set) |>
bind_cols(opt$test_set) |>
metrics(truth = opt$predictor, estimate = .pred) |>
filter(.metric == "rmse")
write_csv(model_summary, "results/model_rmse.csv")
main <- function(train_data, out_dir) {
# read training data
train_set <- read_csv(train_data)
# # create recipe
# model_recipe <- recipe(area ~ DC + DMC + ISI + FFMC + temp + RH, train_set)
#
# # create model specification
# model_spec <- nearest_neighbor(weight_func = "rectangular", neighbors = tune()) |>
#   set_engine("kknn") |>
#   set_mode("regression")
#
# # create workflow
# model_wkflw <- workflow() |>
#   add_recipe(model_recipe) |>
#   add_model(model_spec)
#
# # perform 5 fold cross-validation
# model_cv <- vfold_cv(train_data, v = 5, strata = area)
#
# # hyperparameter tuning
# gridvals <- tibble(neighbors = seq(from = 1, to = 200, by = 3))
#
# model_results <- model_wkflw |>
#   tune_grid(resamples = model_cv, grid = gridvals) |>
#   collect_metrics() |>
#   filter(.metric == "rmse")
#
# min_rmse <- model_results |>
#   filter(mean == min(mean))
#
# k_min <- min_rmse |>
#   pull(neighbors)
# save result as a .csv file
write_csv(train_set, "results/best_k.csv")
}
main(fire_train, "results/train.csv")
main(fire_train, results/train.csv)
main(fire_train, results)
main(fire_train, results)
main(fire_train, "results")
paste0("hello", "why")
main <- function(train_data, out_dir) {
# read training data
train_set <- read_csv(train_data)
# # create recipe
# model_recipe <- recipe(area ~ DC + DMC + ISI + FFMC + temp + RH, train_set)
#
# # create model specification
# model_spec <- nearest_neighbor(weight_func = "rectangular", neighbors = tune()) |>
#   set_engine("kknn") |>
#   set_mode("regression")
#
# # create workflow
# model_wkflw <- workflow() |>
#   add_recipe(model_recipe) |>
#   add_model(model_spec)
#
# # perform 5 fold cross-validation
# model_cv <- vfold_cv(train_data, v = 5, strata = area)
#
# # hyperparameter tuning
# gridvals <- tibble(neighbors = seq(from = 1, to = 200, by = 3))
#
# model_results <- model_wkflw |>
#   tune_grid(resamples = model_cv, grid = gridvals) |>
#   collect_metrics() |>
#   filter(.metric == "rmse")
#
# min_rmse <- model_results |>
#   filter(mean == min(mean))
#
# k_min <- min_rmse |>
#   pull(neighbors)
# save result as a .csv file
write_csv(train_set, paste0(out_dir,"/best_k.csv"))
}
main(fire_train, results)
main(data/forestfires.csv, results)
main(fire_train, results)
suppressPackageStartupMessages({
library(tidyverse)
library(tidymodels)
library(GGally)})
options(repr.plot.width = 15, repr.plot.height = 12)
source("../src/R/data_cleaning.R")
source("../src/R/correlation_graph.R")
source("../src/R/recipe_scale_center.R")
fire_data <- read_csv("../data/forestfires.csv", show_col_types = FALSE)
fire_data <- data_cleaning(fire_data, c('X','Y','month','day'))
"Table 1: Tidied Data"
head(fire_data)
set.seed(2022)
fire_split <- initial_split(fire_data, prop = 0.75, strata = area)
fire_train <- training(fire_split)
fire_test <- testing(fire_split)
fire_recipe <- recipe_scale_center(fire_train, area ~ .)
fire_scaled <- fire_recipe %>%
prep() %>%
bake(fire_train)
correlation_graph(fire_scaled, "Figure 1: Correlation Matrix Between Pairs of Variables")
cor_data <- fire_scaled %>% select(DC, DMC, ISI, FFMC, temp, RH)
correlation_graph(cor_data, "Figure 2: Correlation Matrix Between Pairs of Variables with Large Correlation Values")
fire_recipe <- recipe_scale_center(fire_train, area ~ DC + DMC + ISI + FFMC + temp + RH)
fire_spec <- nearest_neighbor(weight_func = "rectangular", neighbors = tune()) %>%
set_engine("kknn") %>%
set_mode("regression")
fire_cv <- vfold_cv(fire_train, v = 5, strata = area)
fire_wkflw <- workflow() %>%
add_recipe(fire_recipe) %>%
add_model(fire_spec)
gridvals <- tibble(neighbors = seq(from = 1, to = 200, by = 3))
fire_results <- fire_wkflw %>%
tune_grid(resamples = fire_cv, grid = gridvals) %>%
collect_metrics() %>%
filter(.metric == "rmse")
min_rmse <- fire_results %>%
filter(mean == min(mean))
k_min <- min_rmse %>%
pull(neighbors)
"Table 2: The Number of Neighbors with the Minimum RMSE"
min_rmse
test_spec <- nearest_neighbor(weight_func = "rectangular", neighbors = k_min) %>%
set_engine("kknn") %>%
set_mode("regression")
fire_fit <- workflow() %>%
add_recipe(fire_recipe) %>%
add_model(test_spec) %>%
fit(data = fire_train)
fire_summary <- fire_fit %>%
predict(fire_test) %>%
bind_cols(fire_test) %>%
metrics(truth = area, estimate = .pred) %>%
filter(.metric == "rmse")
"Table 3: Testing RMSE"
fire_summary
typeof(k_min)
class(k_min)
typeof(k_min)
typeof(k_min)
class(k_min)
k_min_table <- data.frame(k_min)
k_min_table <- data.frame(k_min)
k_min_table
test_spec <- nearest_neighbor(weight_func = "rectangular", neighbors = k_min) %>%
set_engine("kknn") %>%
set_mode("regression")
fire_fit <- workflow() %>%
add_recipe(fire_recipe) %>%
add_model(test_spec) %>%
fit(data = fire_train)
fire_summary <- fire_fit %>%
predict(fire_test) %>%
bind_cols(fire_test) %>%
metrics(truth = area, estimate = .pred) %>%
filter(.metric == "rmse")
"Table 3: Testing RMSE"
fire_summary
class(fire_summary)
write_csv(fire_train, "data/training_data.csv")
write_csv(fire_train, "data/testing_data.csv")
write_csv(fire_train, "data/training_data.csv")
write_csv(fire_train, "data/testing_data.csv")
suppressPackageStartupMessages({
library(tidyverse)
library(tidymodels)
library(GGally)})
options(repr.plot.width = 15, repr.plot.height = 12)
best_k <- read_csv("../../results/best_k.csv")
best_k <- read_csv("../results/best_k.csv")
best_k <- read_csv("../results/best_k.csv")
knitr::kable(best_k, caption = "The number of neighbours with the minimum RMSE")
suppressPackageStartupMessages({
library(tidyverse)
library(tidymodels)
library(GGally)})
options(repr.plot.width = 15, repr.plot.height = 12)
source("../src/R/data_cleaning.R")
source("../src/R/correlation_graph.R")
source("../src/R/recipe_scale_center.R")
best_k <- read_csv("../results/best_k.csv")
knitr::kable(best_k, caption = "The number of neighbours with the minimum RMSE")
testing_rmse <- read_csv("../results/testing_rmse.csv")
knitr::kable(testing_rmse, caption = "Testing RMSE")
rmse_val <- testing_rmse$.estimate
rmse_val
k_val <- best_k$k_min
k_val
suppressPackageStartupMessages({
library(tidyverse)
library(tidymodels)
library(GGally)})
options(repr.plot.width = 15, repr.plot.height = 12)
source("../src/R/data_cleaning.R")
source("../src/R/correlation_graph.R")
source("../src/R/recipe_scale_center.R")
fire_data <- read_csv("../data/forestfires.csv", show_col_types = FALSE)
fire_data <- data_cleaning(fire_data, c('X','Y','month','day'))
"Table 1: Tidied Data"
head(fire_data)
set.seed(2022)
fire_split <- initial_split(fire_data, prop = 0.75, strata = area)
fire_train <- training(fire_split)
fire_test <- testing(fire_split)
fire_recipe <- recipe_scale_center(fire_train, area ~ .)
fire_scaled <- fire_recipe %>%
prep() %>%
bake(fire_train)
write_csv(fire_train, "data/training_data.csv")
write_csv(fire_test, "data/testing_data.csv")
best_k <- read_csv("../results/best_k.csv")
k_val <- best_k$k_min
knitr::kable(best_k, caption = "The number of neighbours with the minimum RMSE")
testing_rmse <- read_csv("../results/testing_rmse.csv")
rmse_val <- testing_rmse$.estimate
knitr::kable(testing_rmse, caption = "Testing RMSE")
best_k <- read_csv("../results/best_k.csv")
k_val <- best_k$neighbors
knitr::kable(best_k, caption = "The number of neighbours with the minimum RMSE")
best_k <- read_csv("../results/best_k.csv")
k_val <- best_k$neighbors
train_rmse <- best_k$mean
knitr::kable(best_k, caption = "The number of neighbours with the minimum RMSE")
testing_rmse <- read_csv("../results/testing_rmse.csv")
rmse_val <- testing_rmse$.estimate
knitr::kable(testing_rmse, caption = "Testing RMSE")
best_k <- read_csv("../results/best_k.csv")
k_val <- best_k$neighbors
train_rmse <- round(best_k$mean, digits = 4)
knitr::kable(best_k, caption = "The number of neighbours with the minimum RMSE")
best_k <- read_csv("../results/best_k.csv")
k_val <- best_k$neighbors
train_rmse <- round(best_k$mean, digits = 2)
knitr::kable(best_k, caption = "The number of neighbours with the minimum RMSE")
testing_rmse <- read_csv("../results/testing_rmse.csv")
rmse_val <- round(testing_rmse$.estimate, digits = 2)
knitr::kable(testing_rmse, caption = "Testing RMSE")
best_k <- read_csv("../results/best_k.csv")
